#' Return the \code{soilmap} or \code{soilmap_simple} data source as an
#' \code{sf} object
#'
#' Returns either the raw data source \code{soilmap}
#' or (by default) the
#' processed data source \code{soilmap_simple}.
#'
#' The raw data source is published
#' [at DOV](https://www.dov.vlaanderen.be/geonetwork/srv/dut/catalog.search#/metadata/5c129f2d-4498-4bc3-8860-01cb2d513f8f)
#' (Databank Ondergrond Vlaanderen) and
#' is discussed by Van Ranst & Sys (2000) and Dudal et al. (2005).
#' A 'pure' (single) dataformat of the raw data source (no metadatafiles etc.)
#' has also been stored (with versioning) at
#' Zenodo (<https://doi.org/10.5281/zenodo.3387007>), in order
#' to support the `read_soilmap()` function and to sustain long-term workflow
#' reproducibility.
#'
#' Note that factors are generated with implicit \code{NA} values (i.e. there is
#' no factor level to represent the missing values).
#' If you want this category to appear in certain results, you can convert with
#' [forcats::fct_explicit_na()].
#'
#' In case the raw data source \code{soilmap} is used, it is possible to
#' manually perform the standardization for coastal plain features and/or the
#' simplification,
#' both of which were applied in the \code{soilmap_simple} data source
#' See \emph{Arguments} for more information.
#'
#' See R-code in the \href{https://github.com/inbo/n2khab-preprocessing}{
#' n2khab-preprocessing} repository for the creation of the
#' \code{soilmap_simple} data source from
#' the \code{soilmap} data source.
#'
#' @md
#'
#' @param use_processed Logical.
#' If \code{TRUE} (the default), load and return the processed data source
#' \code{soilmap_simple}, instead of the raw data source \code{soilmap}.
#' `soilmap_simple` can be manually generated by reading the raw `soilmap` data
#' source with `standardize_coastalplain=TRUE` and `simplify=TRUE`, but this
#' takes some time.
#' @param standardize_coastalplain Logical.
#' Only applied with \code{use_processed = FALSE}.
#' If \code{TRUE}, fill the values of the morphogenetic substrate,
#' texture and drainage variables (`bsm_mo_substr`, `bsm_mo_tex` and
#' `bsm_mo_drain` + their `_explan` counterparts) _for features in the
#' 'coastalplain' area_ (where these are missing).
#' To derive morphogenetic texture and drainage levels from the geomorphological
#' ones, a translation table by Bruno De Vos &
#' Carole Ampe is applied (for earlier work on this, see Ampe 2013).
#' Substrate classes are copied over from `bsm_ge_substr` into `bsm_mo_substr`
#' (hence, the resulting `bsm_mo_substr` is actually hybrid: 'mo' + 'ge').
#' These steps coincide with the approach that was taken to construct
#' `bsm_mo_soilunitype` in the raw data source.
#' @param simplify Logical.
#' Only applied with \code{use_processed = FALSE}.
#' If \code{TRUE}, only return a limited number of variables.
#'
#' @inheritParams read_habitatmap_stdized
#'
#' @return
#' A Simple feature collection of geometry type \code{MULTIPOLYGON}.
#'
#' @references
#' - Ampe C. (2013). Databank aardewerk Vlaanderen 2010.
#' Omzetten (zeer) oude legende bodemkartering naar legende bodemkaart
#' Kuststreek. Vlaamse Landmaatschappij Regio West, Bruges, 45 p.
#' - Dudal R., Deckers J., Van Orshoven J. & Van Ranst E. (2005). Soil survey
#' in Belgium and its applications. In: Bullock P., Jones R.J.A., Montanarella
#' L. (editors). Soil Resources of Europe. Office for Official Publications of
#' the European Communities, Luxembourg, p. 63â€“71.
#' URL: http://hdl.handle.net/1854/LU-368514.
#' - Van Ranst E. & Sys C. (2000). Eenduidige legende van de digitale
#' bodemkaart van Vlaanderen (schaal 1: 20000). Universiteit Gent, Laboratorium
#' voor Bodemkunde, Ghent, 361 p. URL: http://hdl.handle.net/1854/LU-125899.
#'
#' @importFrom assertthat
#' assert_that
#' is.flag
#' @importFrom sf
#' read_sf
#' @importFrom git2rdata
#' read_vc
#' @importFrom dplyr
#' %>%
#' select
#' mutate
#' mutate_at
#' left_join
#' vars
#' contains
#' @importFrom rlang .data
#' @export
read_soilmap <-
    function(path = fileman_up("n2khab_data"),
             file = "10_raw/soilmap",
             use_processed = TRUE,
             standardize_coastalplain = FALSE,
             simplify = FALSE) {

        assert_that(is.flag(simplify))
        assert_that(is.flag(standardize_coastalplain))
        assert_that(is.flag(use_processed))

        soilmap_path <- file.path(path, file)
        assert_that(file.exists(soilmap_path))

        suppressWarnings(
            soilmap <- read_sf(soilmap_path,
                               crs = 31370)
        )

        soilmap <-
            soilmap %>%
            select(bsm_poly_id = .data$gid,
                   bsm_map_id = .data$Kaartbldnr,
                   bsm_region = .data$Streek,
                   bsm_ge_coastalplain = .data$Type_class,
                   bsm_ge_region = .data$Streek_c,
                   bsm_mo_legend = .data$Grove_leg,
                   bsm_mo_legend_title = .data$Uitleg_tit,
                   bsm_mo_legend_explan = .data$Uitleg,
                   bsm_mo_soiltype_id = .data$codeid,
                   bsm_mo_soiltype = .data$Bodemtype,
                   bsm_mo_soilunitype = .data$Unitype,
                   bsm_mo_soiltype_region = .data$Bodtypstr,
                   bsm_mo_soilseries = .data$Bodemser_c,
                   bsm_mo_soilseries_explan = .data$Bodemserie,
                   bsm_mo_substr = .data$Substr_V_c,
                   bsm_mo_substr_explan = .data$SubstraatV,
                   bsm_mo_tex = .data$Textuur_c,
                   bsm_mo_tex_explan = .data$Textuur,
                   bsm_mo_drain = .data$Drainage_c,
                   bsm_mo_drain_explan = .data$Drainage,
                   bsm_mo_prof = .data$Profontw_c,
                   bsm_mo_prof_explan = .data$Profontw,
                   bsm_mo_phase = .data$Fase_c,
                   bsm_mo_parentmat = .data$Varimoma_c,
                   bsm_mo_parentmat_explan = .data$Varimoma,
                   bsm_mo_profvar = .data$Variprof_c,
                   bsm_mo_profvar_explan = .data$Variprof,
                   bsm_ge_substr = .data$Substr_p_c,
                   bsm_ge_substr_explan = .data$Substr_pol,
                   bsm_ge_series = .data$Serie_c,
                   bsm_ge_series_explan = .data$Serie,
                   bsm_ge_subseries = .data$Subserie_c,
                   bsm_ge_subseries_explan = .data$Subserie,
                   bsm_map_url = .data$Scan_kbl,
                   bsm_book_url = .data$Scan_boek,
                   bsm_detailmap_url = .data$Scan_5000,
                   bsm_profloc_url = .data$Scan_stip
                   ) %>%
            mutate(bsm_ge_coastalplain = .data$bsm_ge_coastalplain == "Zeepolders") %>%
            mutate_at(.vars = vars(-.data$bsm_poly_id,
                                   -.data$bsm_ge_coastalplain,
                                   -.data$bsm_mo_soiltype_id,
                                   -.data$geometry),
                      .funs = factor)

        if (standardize_coastalplain) {
            transl <- read_vc(file = "soil_translation_coastalplain",
                              root = pkgdatasource_path(
                                  "textdata/soil_translation_coastalplain", ".tsv")) %>%
                mutate(soiltype_orig = factor(.data$soiltype_orig,
                                              levels =
                                                  levels(soilmap$bsm_mo_soiltype))
                       ) %>%
                filter(!is.na(.data$texture_transl))

            soilmap <-
                soilmap %>%
                left_join(transl, by = c("bsm_mo_soiltype" = "soiltype_orig")) %>%
                mutate(bsm_mo_substr = as.character(.data$bsm_mo_substr),
                       bsm_mo_tex = as.character(.data$bsm_mo_tex),
                       bsm_mo_drain = as.character(.data$bsm_mo_drain),
                       bsm_mo_substr = ifelse(is.na(.data$bsm_mo_substr) &
                                              !is.na(.data$bsm_ge_substr),
                                          as.character(.data$bsm_ge_substr),
                                          .data$bsm_mo_substr) %>%
                           factor(levels = levels(soilmap$bsm_mo_substr)),
                       bsm_mo_tex = ifelse(is.na(.data$bsm_mo_tex) &
                                            !is.na(.data$texture_transl),
                                        .data$texture_transl,
                                        .data$bsm_mo_tex) %>%
                           factor(levels = levels(soilmap$bsm_mo_tex)),
                       bsm_mo_drain = ifelse(is.na(.data$bsm_mo_drain) &
                                             !is.na(.data$drainage_transl),
                                         .data$drainage_transl,
                                         .data$bsm_mo_drain) %>%
                           factor(levels = levels(soilmap$bsm_mo_drain))
                       ) %>%
                select(-contains("transl"))

        }

        if (simplify) {
            soilmap <-
                soilmap %>%
                select(.data$bsm_poly_id,
                       .data$bsm_region,
                       .data$bsm_ge_coastalplain,
                       .data$bsm_mo_soilunitype,
                       .data$bsm_mo_substr,
                       .data$bsm_mo_tex,
                       .data$bsm_mo_drain,
                       .data$bsm_mo_prof,
                       .data$bsm_mo_parentmat,
                       .data$bsm_mo_profvar
                       )
        }

        return(soilmap)

    }
